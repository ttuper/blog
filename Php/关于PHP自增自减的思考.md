在做一道引用相关的笔试题时遇到的问题。

	<?php
	$a = 1;
	
	$b = &$a;
	
	$b = $a++;
	
	echo "a=" . $a . ",b=" . $b;

问最后结果是什么。  
我给出的答案是：a=2,b=2。  
思考经过如下：  
`$a = 1`，变量a被赋值为1，内存中开辟了一块空间，存放着值1；  
`$b = &$a`，变量b指向了变量a的内存空间，变量b的值也为1；  
`$b = $a++`，此处，我的分解步骤变成这样，`$b = $a; $a = $a + 1`，于是，我认为变量b的值就为1，变量a的值因为自增变成2，但是b是a的引用，a的值变了，b也应该跟着变，所以b最后也为2。  
自我感觉是对的，自认为变量自增应该注意的点也注意到了，引用的点也注意到了。  
但是，其实我忽略了运算符优先级的概念。  
这句`$b = $a++`，我将其拆分成`$b = $a; $a = $a + 1`，这样的执行顺序是不对的，**因为赋值运算符优先级肯定是小于加法运算符的**。应该拆分成这样`$a = $a + 1; $b = $a;`，这样的话其实也是不对的，因为我们都知道，b的值不会变成a自增后的值，这是后自增的基本概念。如果按照这样拆分执行的话，最后的结果就应该是`$a = 2, $b = 2`，所以这里我们还漏了什么。  

**接下来理解一下php中则自增自减是怎么实现的（此处仅以前自增和后自增为例，前自减后自减相同）**

1）前自增  
`$b = ++$a`  
执行顺序：  
`$a = $a + 1; $b = $a`,前自增这样是没问题的

2）后自增  
`$b = $a++`  
执行顺序：  
`$temp = $a; $a = $a + 1; $b = $temp;`  
看到了吗，后自增和前自增的区别，这里后自增是会定义一个临时变量存储a的值，a再去自增，而再将临时变量得值赋给b

所以按照这样的运算规则的话，上面的代码执行的结果即为：  
`$a = 1, $b = 1`  
因为`$temp = $a; $a = $a + 1; `，此时a=2，但是后面得`$b = $temp;`，b就被赋值为1，因为b是对变量a得引用，所以b变成1了，a也就变成1了。

这里涉及到了php源码得分析，有时间再仔细研究下源码对这块得具体实现。




